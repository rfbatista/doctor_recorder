package webrtc

import (
	"doctor_recorder/internal/infrastructure/logger"

	"github.com/hashicorp/go-multierror"
	"github.com/pion/interceptor"
	"github.com/pion/interceptor/pkg/intervalpli"
	"github.com/pion/webrtc/v4"
)

// var (
// 	audioBuilder, videoBuilder     *samplebuilder.SampleBuilder
// 	audioTimestamp, videoTimestamp time.Duration
// 	streamKey                      string
// )

type WebRTCServer struct {
	config     WebRTCConfig
	api        *webrtc.API
	PeerConfig *webrtc.Configuration
	log        *logger.Logger
	Peers      Peers
}

func NewWebRTCServer(c WebRTCConfig, log *logger.Logger) (WebRTCServer, error) {
	return WebRTCServer{config: c, log: log, Peers: make(Peers)}, nil
}

func (w *WebRTCServer) Init() error {
	// Create a MediaEngine object to configure the supported codec
	m := &webrtc.MediaEngine{}

	// Setup the codecs you want to use.
	// We'll use a VP8 and Opus but you can also define your own
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeVP8, ClockRate: 90000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        96,
	}, webrtc.RTPCodecTypeVideo); err != nil {
		return multierror.Append(FailedToSetupCodecs, err)
	}
	if err := m.RegisterCodec(webrtc.RTPCodecParameters{
		RTPCodecCapability: webrtc.RTPCodecCapability{MimeType: webrtc.MimeTypeOpus, ClockRate: 48000, Channels: 0, SDPFmtpLine: "", RTCPFeedback: nil},
		PayloadType:        111,
	}, webrtc.RTPCodecTypeAudio); err != nil {
		return multierror.Append(FailedToSetupCodecs, err)
	}

	// Create a InterceptorRegistry. This is the user configurable RTP/RTCP Pipeline.
	// This provides NACKs, RTCP Reports and other features. If you use `webrtc.NewPeerConnection`
	// this is enabled by default. If you are manually managing You MUST create a InterceptorRegistry
	// for each PeerConnection.
	i := &interceptor.Registry{}

	// Register a intervalpli factory
	// This interceptor sends a PLI every 3 seconds. A PLI causes a video keyframe to be generated by the sender.
	// This makes our video seekable and more error resilent, but at a cost of lower picture quality and higher bitrates
	// A real world application should process incoming RTCP packets from viewers and forward them to senders
	intervalPliFactory, err := intervalpli.NewReceiverInterceptor()
	if err != nil {
		return multierror.Append(FailedToSetupInterceptors, err)
	}
	i.Add(intervalPliFactory)

	w.PeerConfig = &webrtc.Configuration{
		ICEServers: []webrtc.ICEServer{
			{
				URLs: []string{"stun:stun.l.google.com:19302"},
			},
		},
	}
	w.api = webrtc.NewAPI(webrtc.WithMediaEngine(m))
	if w.PeerConfig == nil {
		panic("")
	}
	if w.api == nil {
		panic("")
	}
	return nil
}
